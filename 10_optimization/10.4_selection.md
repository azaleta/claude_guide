## 10.4 模型选择与路由策略 (Model Routing & Cascading)

在 AI 工程中，"One Model Fits All" 是一个谎言。
为了在质量、成本和延迟之间找到最优解，需要构建一个 **Model Router (模型路由器)**。

### 10.4.1 模型分层 (The Model Hierarchy)

| Tier | Model | 擅长 | 成本 | 延迟 |
| :--- | :--- | :--- | :--- | :--- |
| **S-Tier** | **Claude 4 Opus** | 复杂推理、创意写作、极端边缘情况处理 | $$$ | 慢 |
| **A-Tier** | **Claude 4.5 Sonnet** | 编程、数据分析、通用任务 (性价比之王) | $$ | 中 |
| **B-Tier** | **Claude 3.5 Haiku** | 简单分类、提取、翻译、聊天 | ¢ | 极快 |

### 10.4.2 静态路由 (Static Routing)

最简单的路由是基于任务类型的硬编码。

```python
def route_request(task_type, prompt):
    if task_type == "coding":
        return call_sonnet(prompt)
    elif task_type == "summarization":
        return call_haiku(prompt) # Haiku 读长文很便宜
    elif task_type == "creative_writing":
        return call_opus(prompt)
```

**优点**: 实现简单，可预测性强。
**缺点**: 不灵活，Haiku 其实也能写简单的代码，全用 Sonnet 浪费了。

### 10.4.3 动态路由 (Dynamic Routing)

使用一个极小的模型（如 BERT 分类器或专门微调过的 Haiku）作为 **Router**。

**Router Prompt**:
> "评估以下用户请求的复杂度（Level 1-5）。
> Level 1-2: 日常问候、简单事实查询。-> Route to Haiku.
> Level 3-4: 编程、逻辑推理、文档分析。-> Route to Sonnet.
> Level 5: 极其复杂的数学证明、哲学思辨。-> Route to Opus."

### 10.4.4 级联降级 (Cascading / Fallback)

这是一种“不仅要便宜，还要兜底”的策略。
默认尝试便宜模型，失败了才摇人。

**Coding Task Workflow**:
1.  **Attempt 1**: 先用 **Haiku** 尝试写代码。
2.  **Verify**: 运行单元测试。
    *   如果通过 -> Return (成本 $0.01)。
    *   如果失败 -> 进入 Next Step。
3.  **Attempt 2**: 将 Haiku 写的代码和报错信息一起发给 **Sonnet**。
4.  **Fix**: Sonnet 修复代码。 -> Return (成本 $0.11)。

通过这种机制，大约 60% 的简单任务被 Haiku 拦截解决了，只有 40% 的硬骨头留给了 Sonnet，综合成本下降 50% 以上。

### 10.4.5 A/B Testing 与 Evals

如何知道路由策略是否有效？需要建立 **Evals (评估体系)**。
*   构建一个包含 100 个典型 User Query 的 Golden Dataset。
*   分别用 Opus, Sonnet, Haiku 跑一遍。
*   人工或让 Opus 给结果打分。
*   可以画出一条 **Pareto Frontier (帕累托前沿)** 曲线，找到那个“质量虽然下降 5%，但成本下降 80%”的甜蜜点 (Sweet Spot)。

---

到目前为止，已经把模型“榨干”了——既让它干复杂的活，又通过各种手段压榨成本。
但在在这个过程中，是否忽略了什么？
当 AI 变得越来越强大，越来越便宜，它会不会失控？它会不会被坏人利用？
**Safety (安全)** 不仅仅是设一道防火墙，它是 AI 产品的生命线。

➡️ [第十一章：安全与伦理](../11_safety/README.md)
